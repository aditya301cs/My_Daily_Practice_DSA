class Solution {
  public:
    long long atMostK(vector<int>& arr, int k) {
        if (k < 0) return 0;

        int i = 0;
        int oddCount = 0;
        long long count = 0;

        for (int j = 0; j < arr.size(); j++) {
            if (arr[j] & 1) oddCount++;

            while (oddCount > k) {
                if (arr[i] & 1) oddCount--;
                i++;
            }

            count += (j - i + 1);
        }
        return count;
    }

    int countSubarrays(vector<int>& arr, int k) {
        return atMostK(arr, k) - atMostK(arr, k - 1);
    }
};



/*
Concept & Optimizations:

1) Exactly K Odd Numbers:
   Sliding window works reliably only for inequality conditions (≤ K),
   not for exact equality. Therefore:
     Subarrays with exactly K odds
     = atMostK(K) − atMostK(K−1)

   atMostK(K) counts all subarrays having 0..K odd numbers.
   atMostK(K−1) removes subarrays having fewer than K odds.
   The difference leaves only subarrays with exactly K odd numbers.

2) Sliding Window Invariant:
   While counting at most K odds, once a window is valid (oddCount ≤ K),
   all its subarrays are also valid. Hence:
     count += (j − i + 1)

3) Use of long long:
   The number of subarrays can be O(n²). For n = 10⁵, the count can exceed
   the range of int. Therefore, long long is required to avoid overflow.

4) Edge Case Handling:
   When K = 0, we may call atMostK(-1). Since no subarray can have negative
   odd numbers, atMostK(k < 0) safely returns 0.
*/
